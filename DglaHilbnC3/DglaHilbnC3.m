(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["DglaHilbnC3`",{"Helpers`"}];


SetupDgla::usage="Set up the dgla using the partition describing a monimial ideal.";
CleanDgla::usage="Clean up the dgla.";
Dgla::usage="Returns the dgla associated with the partition used in SetupDgla. Currently will override previous SetupDgla";
d::usage="The differential";
c::usage="The graded Lie bracket";


Begin["`Private`"];


SetupDgla[\[Mu]in_List]:=Module[{},
CleanDgla[];
\[Mu]=\[Mu]in;
]


CleanDgla[]:=Module[{},
ClearCache/@Unevaluated/@Unevaluated[{\[Mu],B,c,d,pp,P,n}];
]


Dgla[\[Mu]in_]:=Module[{top=3,result},
SetupDgla[\[Mu]in];
result={
Table[{i,d[i]},{i,0,top-1}],Flatten[Table[{{i,j},c[i,j]},{i,0,top},{j,0,top-i}],1]
};
CleanDgla[];
result
]


e[i_]:=e[i]=Table[KroneckerDelta[i,j],{j,1,3}];
\[Delta]=KroneckerDelta;
\[Delta]12[i_,J_]:=\[Delta]12[i,J]=Boole[{{2,3},{3,1},{1,2}}[[i]]==J];


B[x_]:=B[x]=Switch[x,
0,Flatten[Outer[List,\[Mu],\[Mu],1],1],
1,Flatten[Outer[List,{1,2,3},\[Mu],\[Mu],1],2],
2,Flatten[Outer[List,{{2,3},{3,1},{1,2}},\[Mu],\[Mu],1],2],
3,B[0]
];


d[i_]:=d[i]=ct[c[1,i],Apply[P,B[1],1],2,1];


c[a_Integer,b_Integer]:=c[a,b]=If[b<a,Transpose[-(-1)^(a b)c[b,a],{1,3,2}],
SparseArray@Switch[{a,b},
{0,0},
Module[{h,r,p,q,s,t},
Table[
{h,r}=\[Beta];
{p,q}=\[Alpha]1;
{s,t}=\[Alpha]2;
\[Delta][h,p]\[Delta][q,s]\[Delta][r,t]-\[Delta][p,t]\[Delta][r,q]\[Delta][h,s]
,{\[Beta],B[0]},{\[Alpha]1,B[0]},{\[Alpha]2,B[0]}]
],
{0,1},
Module[{i,l,h,r,p,q,s,t},
Table[
{i,h,r}=\[Beta];
{p,q}=\[Alpha]1;
{l,s,t}=\[Alpha]2;
\[Delta][i,l](\[Delta][h,p]\[Delta][q,s]\[Delta][r,t]-\[Delta][p,t]\[Delta][r,q]\[Delta][h,s])
,{\[Beta],B[1]},{\[Alpha]1,B[0]},{\[Alpha]2,B[1]}]
],
{0,2},
Module[{J,K,h,r,p,q,s,t},
Table[
{J,h,r}=\[Beta];
{p,q}=\[Alpha]1;
{K,s,t}=\[Alpha]2;
\[Delta][J,K](\[Delta][h,p]\[Delta][q,s]\[Delta][r,t]-\[Delta][p,t]\[Delta][r,q]\[Delta][h,s])
,{\[Beta],B[2]},{\[Alpha]1,B[0]},{\[Alpha]2,B[2]}]
],
{0,3},
Module[{h,r,p,q,s,t},
Table[
{h,r}=\[Beta];
{p,q}=\[Alpha]1;
{s,t}=\[Alpha]2;
(\[Delta][h,p]\[Delta][q,s]\[Delta][r,t]-\[Delta][p,t]\[Delta][r,q]\[Delta][h,s])
,{\[Beta],B[3]},{\[Alpha]1,B[0]},{\[Alpha]2,B[3]}]
],
{1,1},
Module[{i,j,k,l,h,r,p,q,s,t},
Table[
{{i,j},h,r}=\[Beta];
{k,p,q}=\[Alpha]1;
{l,s,t}=\[Alpha]2;
(\[Delta][i,k]\[Delta][j,l]-\[Delta][i,l]\[Delta][j,k])(\[Delta][h,p]\[Delta][q,s]\[Delta][r,t]-\[Delta][p,t]\[Delta][r,q]\[Delta][h,s])
,{\[Beta],B[2]},{\[Alpha]1,B[1]},{\[Alpha]2,B[1]}]
],
{1,2},
Module[{i,J,h,r,p,q,s,t},
Table[
{h,r}=\[Beta];
{i,p,q}=\[Alpha]1;
{J,s,t}=\[Alpha]2;
\[Delta]12[i,J](\[Delta][h,p]\[Delta][q,s]\[Delta][r,t]-\[Delta][p,t]\[Delta][r,q]\[Delta][h,s])
,{\[Beta],B[3]},{\[Alpha]1,B[1]},{\[Alpha]2,B[2]}]
],
_,
0
]
];


End[];
EndPackage[];
