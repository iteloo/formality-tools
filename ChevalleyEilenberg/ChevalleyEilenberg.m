(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["ChevalleyEilenberg`",{"Helpers`"}]


SetupCEComplex::usage="Set up for computation using the input dgla."
CleanCEComplex::usage="Clean up symbols related to the current dgla."
euler::usage="Returns the Euler class in \!\(\*SubscriptBox[\"E\", \"1\"]\)."
\[Delta]0::usage="Returns matrix for (\!\(\*SubscriptBox[\"\[Delta]\", \"0\"]\)\!\(\*SuperscriptBox[\")\", 
RowBox[{\"p\", \",\", \"q\"}]]\):\!\(\*SuperscriptBox[\"A\", 
RowBox[{\"p\", \",\", \"q\"}]]\)\[Rule]\!\(\*SuperscriptBox[\"A\", 
RowBox[{\"p\", \",\", 
RowBox[{\"q\", \"+\", \"1\"}]}]]\)."
\[Delta]1::usage="Returns matrix for (\!\(\*SubscriptBox[\"\[Delta]\", \"1\"]\)\!\(\*SuperscriptBox[\")\", 
RowBox[{\"p\", \",\", \"q\"}]]\):\!\(\*SuperscriptBox[\"A\", 
RowBox[{
RowBox[{\"p\", \"+\", \"1\"}], \",\", \"q\"}]]\)\[Rule]\!\(\*SuperscriptBox[\"A\", 
RowBox[{\"p\", \",\", \"q\"}]]\)."


Begin["`Private`"]


\[Delta]=Composition[Boole,SameQ];
spId[n_]:=SparseArray[{i_,i_}->1,{n,n}];
exportSparseToMATLAB[filename_,sp_]:=Module[{rules},
rules=ArrayRules[SparseArray[sp]];
rules[[-1]]=Dimensions[sp]->0.;
Export[filename,Append[#[[1]],#[[2]]]&/@rules,"Table"];
]


deg[b_b]:=First[b];
genDim[n_]:={n^2,3n^2,3n^2,n^2};
display[v_]:=Module[{f=HoldForm[#1\[RightTeeArrow]#2]&,g=Subscript[#2,Style[#1,FontColor->Lighter[Gray]]]&},
v/.{prod->Composition[HoldForm,Times],map->f,b->g}
];


(* input form expected: {{0,d[0]},{1,d[1]},{2,d[2]},...},{...,{{1,1},c[1,1]},...} *)
SetupCEComplex[{dlist_,clist_}]:=Module[{},
CleanCEComplex[];
nonzeroDegrees={};
dim[i_]:=0;
paddedD[i_]:=paddedD[i]=SparseArray[{},{If[i==top,1,Max[dim[i+1],1]],Max[dim[i],1]}];
(* todo: check lengths equal *)
Do[
dim[First[ditem]]=Last@Dimensions[Last[ditem]];
dim[First[ditem]+1]=First@Dimensions[Last[ditem]];
paddedD[First[ditem]]=d[First[ditem]]=Last[ditem];
nonzeroDegrees=nonzeroDegrees~Join~{First[ditem],First[ditem]+1};
,{ditem,dlist}];
nonzeroDegrees=Union[nonzeroDegrees];
top=Max[nonzeroDegrees];
Do[
L[i]=b[i,#]&/@Range[dim[i]];
,{i,nonzeroDegrees}];
Do[
Evaluate[c@@First[citem]]=Last[citem];
,{citem,clist}];
]


(* clean up private and public variables *)
CleanCEComplex[]:=Module[{},
ClearCache/@Unevaluated/@Unevaluated[
{nonzeroDegrees,dim,top,L,d,paddedD,c,LI,AI,\[Chi],\[Delta]0,\[Delta]1,euler}
];
]


(* returns basis for (L^\[Wedge]p)^i *)
LI[p_,i_]:=LI[p,i]=prod@@@Flatten[Permutations/@IntegerPartitions[i,{p},nonzeroDegrees],1];


(* returns indices for i,Subscript[i, 1],...,Subscript[i, p] *)
AI[p_,q_]:=AI[p,q]=Module[{},
Flatten[Table[
If[dim[i+q]!=0&&Length[LI[p,i]]!=0,map[#,i+q]&/@LI[p,i],##&[]]
,{i,Max[0,-q],Min[top-q,p top]}]]
]


(* returns the Koszul sign; involves various hacks *)
\[Chi][\[Sigma]_List,degrees_List]:=\[Chi][\[Sigma],degrees]=Module[{n=Length[\[Sigma]],remainingDegrees=degrees[[\[Sigma]]],sum=0},
Do[
sum+=remainingDegrees[[i]]Total[remainingDegrees[[;;i-1]]];
remainingDegrees[[i]]=0;
,{i,\[Sigma]}];
(-1)^sum Signature[\[Sigma]]
]


(* return special cases of \[Chi] to save computation *)
\[Chi][i_Integer,degrees_List]:=\[Chi][i,degrees]=Module[{n=Length[degrees]},
(-1)^(degrees[[i]]Total[degrees[[i+1;;]]]+(n-i))
];
\[Chi][i_Integer,j_Integer,degrees_List]:=\[Chi][i,j,degrees]=Module[{n=Length[degrees]},
(-1)^(degrees[[j]](Total[degrees[[j+1;;]]])+(n-j)+degrees[[i]](Total[degrees[[i+1;;]]])+(n-i)+If[i<j,degrees[[i]]degrees[[j]]+1,0])
]


(* returns matrix for (Subscript[\[Delta], 0])^(p,q):A^(p,q)->A^(p,q+1) *)
\[Delta]0[p_,q_]:=\[Delta]0[p,q]=Module[{label="",progress=0,maxProg=Length@AI[p,q]Length@AI[p,q+1],result},
SetSharedVariable[progress,label,maxProg];
SetSharedFunction[spId,dim,d,c];
Print["Computing \[Delta]0[",ToString[p],",",ToString[q],"]: ",ProgressIndicator[Dynamic[progress],{0,maxProg}]," ",
Dynamic[label]];
result=WaitAll@Table[
ParallelSubmit[{V,W},
progress+=1;
label=ToString[progress]<>"/"<>ToString[maxProg];
Module[{J,j,L,l,Jdim,jdim,Ldim,ldim,sum},
{{J,j},{L,l}}={V,W}/.{map->List,prod->List};
{Jdim,jdim,Ldim,ldim}=Map[dim,{J,j,L,l},{-1}];
sum=SparseArray[{},{jdim Times@@Jdim,ldim Times@@Ldim}];
If[j==l+1&&J==L,
sum+=Flatten[Outer[Times,
spId[Times@@Ldim],
d[l]
],{{1,3},{2,4}}]];
Do[If[j==l&&Drop[J,{m}]==Drop[L,{m}]&&J[[m]]==L[[m]]-1,
sum-=(-1)^(q+Total[L[[;;m-1]]])Flatten[
Outer[Times,
spId[Times@@Ldim[[;;m-1]]],
d[L[[m]]-1],
spId[ldim Times@@Ldim[[m+1;;]]]
],{{1,4,5},{2,3,6}}]];
,{m,p}];
(*Print[$KernelID,": ",MemoryInUse[]];*)
sum
]
]
,{V,AI[p,q+1]},{W,AI[p,q]}];
label="Done";
SparseArray@ArrayFlatten[result]
]


(* returns matrix for (Subscript[\[Delta], 1])^(p,q):A^(p+1,q)->A^(p,q) *)
\[Delta]1[p_,q_]:=\[Delta]1[p,q]=Module[{label="",progress=0,maxProg=Length@AI[p,q]Length@AI[p+1,q],result},
SetSharedVariable[progress,label,maxProg];
SetSharedFunction[spId,dim,d,c];
Print["Computing \[Delta]1[",ToString[p],",",ToString[q],"]: ",ProgressIndicator[Dynamic[progress],{0,maxProg}]," ",
Dynamic[label]];
result=(-1)^(p+q)WaitAll@Table[
ParallelSubmit[{V,W},
progress+=1;
label=StringExpression["V=",ToString[V]," W=",ToString[W]];
Module[{J,j,L,l,Jdim,jdim,Ldim,ldim,sum},
{{J,j},{L,l}}={V,W}/.{map->List,prod->List};
{Jdim,jdim,Ldim,ldim}=Map[dim,{J,j,L,l},{-1}];
sum=SparseArray[{},{jdim Times@@Jdim,ldim Times@@Ldim}];
Do[If[J[[m]]+l==j&&Drop[J,{m}]==L,
sum+=\[Chi][m,J]Flatten[Outer[Times,
spId[Times@@Jdim[[;;m-1]]],
c[l,J[[m]]],
spId[Times@@Jdim[[m+1;;]]]
],{{1,5,6,3},{2,7,4}}]]
,{m,p+1}];
Do[If[L[[p]]==J[[m]]+J[[n]]&&l==j&&Drop[L,{p}]==Delete[J,{{m},{n}}],
sum-=\[Chi][m,n,J]Flatten[Outer[Times,
spId[Times@@Jdim[[;;m-1]]],
spId[Times@@Jdim[[m+1;;n-1]]],
spId[Times@@Jdim[[n+1;;]]],
spId[jdim],
c[J[[m]],J[[n]]]
],{{1,10,3,11,5,7},{2,4,6,9,8}}]]
,{m,p+1},{n,m+1,p+1}];
sum
]
]
,{V,AI[p+1,q]},{W,AI[p,q]}];
label="Done";
SparseArray@ArrayFlatten[result]
]


(* returns a representative of the Euler derivation in A^(1,0) *)
euler:=euler=Module[{h,em},
h[i_]:=SparseArray[Orthogonalize[NullSpace[paddedD[i]~Join~PseudoInverse[paddedD[i-1]]]]];
em[i_]:=Sum[i Outer[Times,v,v],{v,h[i]}];
Flatten[Table[em[i],{i,nonzeroDegrees}]]
]//SparseArray


End[]
EndPackage[]
